diff -ur gst-plugins-base-0.10.19.orig/ext/gio/gstgiobasesrc.c gst-plugins-base-0.10.19/ext/gio/gstgiobasesrc.c
--- gst-plugins-base-0.10.19.orig/ext/gio/gstgiobasesrc.c	2008-03-18 06:54:12.000000000 +0000
+++ gst-plugins-base-0.10.19/ext/gio/gstgiobasesrc.c	2008-06-12 15:19:17.000000000 +0100
@@ -37,14 +37,21 @@
     GST_TYPE_BASE_SRC);
 
 static void gst_gio_base_src_finalize (GObject * object);
+
 static gboolean gst_gio_base_src_start (GstBaseSrc * base_src);
+
 static gboolean gst_gio_base_src_stop (GstBaseSrc * base_src);
+
 static gboolean gst_gio_base_src_get_size (GstBaseSrc * base_src,
     guint64 * size);
 static gboolean gst_gio_base_src_is_seekable (GstBaseSrc * base_src);
+
 static gboolean gst_gio_base_src_unlock (GstBaseSrc * base_src);
+
 static gboolean gst_gio_base_src_unlock_stop (GstBaseSrc * base_src);
+
 static gboolean gst_gio_base_src_check_get_range (GstBaseSrc * base_src);
+
 static GstFlowReturn gst_gio_base_src_create (GstBaseSrc * base_src,
     guint64 offset, guint size, GstBuffer ** buf);
 
@@ -64,7 +71,9 @@
 gst_gio_base_src_class_init (GstGioBaseSrcClass * klass)
 {
   GObjectClass *gobject_class;
+
   GstElementClass *gstelement_class;
+
   GstBaseSrcClass *gstbasesrc_class;
 
   gobject_class = (GObjectClass *) klass;
@@ -107,6 +116,11 @@
     src->stream = NULL;
   }
 
+  if (src->cache) {
+    gst_buffer_unref (src->cache);
+    src->cache = NULL;
+  }
+
   GST_CALL_PARENT (G_OBJECT_CLASS, finalize, (object));
 }
 
@@ -132,7 +146,9 @@
 gst_gio_base_src_stop (GstBaseSrc * base_src)
 {
   GstGioBaseSrc *src = GST_GIO_BASE_SRC (base_src);
+
   gboolean success;
+
   GError *err = NULL;
 
   if (G_IS_INPUT_STREAM (src->stream)) {
@@ -167,6 +183,7 @@
 
   if (G_IS_FILE_INPUT_STREAM (src->stream)) {
     GFileInfo *info;
+
     GError *err = NULL;
 
     info = g_file_input_stream_query_info (G_FILE_INPUT_STREAM (src->stream),
@@ -189,11 +206,17 @@
 
       g_clear_error (&err);
     }
-  } else if (GST_GIO_STREAM_IS_SEEKABLE (src->stream)) {
+  }
+
+  if (GST_GIO_STREAM_IS_SEEKABLE (src->stream)) {
     goffset old;
+
     goffset stream_size;
+
     gboolean ret;
+
     GSeekable *seekable = G_SEEKABLE (src->stream);
+
     GError *err = NULL;
 
     old = g_seekable_tell (seekable);
@@ -246,6 +269,7 @@
 gst_gio_base_src_is_seekable (GstBaseSrc * base_src)
 {
   GstGioBaseSrc *src = GST_GIO_BASE_SRC (base_src);
+
   gboolean seekable;
 
   seekable = GST_GIO_STREAM_IS_SEEKABLE (src->stream);
@@ -293,56 +317,114 @@
     GstBuffer ** buf_return)
 {
   GstGioBaseSrc *src = GST_GIO_BASE_SRC (base_src);
+
   GstBuffer *buf;
-  gssize read;
-  gboolean success, eos;
+
   GstFlowReturn ret = GST_FLOW_OK;
-  GError *err = NULL;
 
   g_return_val_if_fail (G_IS_INPUT_STREAM (src->stream), GST_FLOW_ERROR);
 
-  if (G_UNLIKELY (offset != src->position)) {
-    if (!GST_GIO_STREAM_IS_SEEKABLE (src->stream))
-      return GST_FLOW_NOT_SUPPORTED;
-
-    ret = gst_gio_seek (src, G_SEEKABLE (src->stream), offset, src->cancel);
-
-    if (ret == GST_FLOW_OK)
-      src->position = offset;
-    else
-      return ret;
-  }
+  /* If we have the requested part in our cache take a subbuffer of that,
+   * otherwise fill the cache again with at least 4096 bytes from the
+   * requested offset and return a subbuffer of that.
+   *
+   * We need caching because every read/seek operation will need to go
+   * over DBus if our backend is GVfs and this is painfully slow. */
+  if (src->cache && offset >= GST_BUFFER_OFFSET (src->cache) &&
+      offset + size <= GST_BUFFER_OFFSET_END (src->cache)) {
 
-  buf = gst_buffer_new_and_alloc (size);
+    GST_DEBUG_OBJECT (src, "Creating subbuffer from cached buffer: offset %"
+        G_GUINT64_FORMAT " length %u", offset, size);
 
-  GST_LOG_OBJECT (src, "reading %u bytes from offset %" G_GUINT64_FORMAT,
-      size, offset);
+    buf = gst_buffer_create_sub (src->cache,
+        offset - GST_BUFFER_OFFSET (src->cache), size);
 
-  read =
-      g_input_stream_read (G_INPUT_STREAM (src->stream), GST_BUFFER_DATA (buf),
-      size, src->cancel, &err);
-
-  success = (read >= 0);
-  eos = (size > 0 && read == 0);
-
-  if (!success && !gst_gio_error (src, "g_input_stream_read", &err, &ret)) {
-    GST_ELEMENT_ERROR (src, RESOURCE, READ, (NULL),
-        ("Could not read from stream: %s", err->message));
-    g_clear_error (&err);
-  }
-
-  if (success && !eos) {
-    src->position += read;
     GST_BUFFER_OFFSET (buf) = offset;
-    GST_BUFFER_SIZE (buf) = read;
-    *buf_return = buf;
+    GST_BUFFER_OFFSET_END (buf) = offset + size;
+    GST_BUFFER_SIZE (buf) = size;
   } else {
-    /* !success || eos */
-    gst_buffer_unref (buf);
+    guint cachesize = MAX (4096, size);
+
+    gssize read, res;
+
+    gboolean success, eos;
+
+    GError *err = NULL;
+
+    if (src->cache) {
+      gst_buffer_unref (src->cache);
+      src->cache = NULL;
+    }
+
+    if (G_UNLIKELY (offset != src->position)) {
+      if (!GST_GIO_STREAM_IS_SEEKABLE (src->stream))
+        return GST_FLOW_NOT_SUPPORTED;
+
+      GST_DEBUG_OBJECT (src, "Seeking to position %" G_GUINT64_FORMAT, offset);
+      ret = gst_gio_seek (src, G_SEEKABLE (src->stream), offset, src->cancel);
+
+      if (ret == GST_FLOW_OK)
+        src->position = offset;
+      else
+        return ret;
+    }
+
+    src->cache = gst_buffer_new_and_alloc (cachesize);
+
+    GST_LOG_OBJECT (src, "Reading %u bytes from offset %" G_GUINT64_FORMAT,
+        cachesize, offset);
+
+    /* GIO sometimes gives less bytes than requested although
+     * it's not at the end of file. SMB for example only
+     * supports reads up to 64k. So we loop here until we get at
+     * at least the requested amount of bytes or a read returns
+     * nothing. */
+    read = 0;
+    while (size - read > 0 && (res =
+            g_input_stream_read (G_INPUT_STREAM (src->stream),
+                GST_BUFFER_DATA (src->cache) + read, cachesize - read,
+                src->cancel, &err)) > 0) {
+      read += res;
+    }
+
+    success = (read >= 0);
+    eos = (cachesize > 0 && read == 0);
+
+    if (!success && !gst_gio_error (src, "g_input_stream_read", &err, &ret)) {
+      GST_ELEMENT_ERROR (src, RESOURCE, READ, (NULL),
+          ("Could not read from stream: %s", err->message));
+      g_clear_error (&err);
+    }
+
+    if (success && !eos) {
+      src->position += read;
+      GST_BUFFER_SIZE (src->cache) = read;
+
+      GST_BUFFER_OFFSET (src->cache) = offset;
+      GST_BUFFER_OFFSET_END (src->cache) = offset + read;
+
+      GST_DEBUG_OBJECT (src, "Read successful");
+      GST_DEBUG_OBJECT (src, "Creating subbuffer from new "
+          "cached buffer: offset %" G_GUINT64_FORMAT " length %u", offset,
+          size);
+
+      buf = gst_buffer_create_sub (src->cache, 0, MIN (size, read));
+
+      GST_BUFFER_OFFSET (buf) = offset;
+      GST_BUFFER_OFFSET_END (buf) = offset + MIN (size, read);
+      GST_BUFFER_SIZE (buf) = MIN (size, read);
+    } else {
+      GST_DEBUG_OBJECT (src, "Read not successful");
+      gst_buffer_unref (src->cache);
+      src->cache = NULL;
+      buf = NULL;
+    }
+
+    if (eos)
+      ret = GST_FLOW_UNEXPECTED;
   }
 
-  if (eos)
-    ret = GST_FLOW_UNEXPECTED;
+  *buf_return = buf;
 
   return ret;
 }
@@ -351,6 +433,7 @@
 gst_gio_base_src_set_stream (GstGioBaseSrc * src, GInputStream * stream)
 {
   gboolean success;
+
   GError *err = NULL;
 
   g_return_if_fail (G_IS_INPUT_STREAM (stream));
diff -ur gst-plugins-base-0.10.19.orig/ext/gio/gstgiobasesrc.h gst-plugins-base-0.10.19/ext/gio/gstgiobasesrc.h
--- gst-plugins-base-0.10.19.orig/ext/gio/gstgiobasesrc.h	2007-12-29 17:29:16.000000000 +0000
+++ gst-plugins-base-0.10.19/ext/gio/gstgiobasesrc.h	2008-06-12 15:18:52.000000000 +0100
@@ -49,6 +49,8 @@
   GCancellable *cancel;
   guint64 position;
   GInputStream *stream;
+
+  GstBuffer *cache;
 };
 
 struct _GstGioBaseSrcClass 
diff -ur gst-plugins-base-0.10.19.orig/ext/gio/gstgio.c gst-plugins-base-0.10.19/ext/gio/gstgio.c
--- gst-plugins-base-0.10.19.orig/ext/gio/gstgio.c	2008-03-03 06:03:44.000000000 +0000
+++ gst-plugins-base-0.10.19/ext/gio/gstgio.c	2008-04-20 11:11:54.000000000 +0100
@@ -29,6 +29,8 @@
 #include "gstgiostreamsink.h"
 #include "gstgiostreamsrc.h"
 
+#include <string.h>
+
 GST_DEBUG_CATEGORY_STATIC (gst_gio_debug);
 #define GST_CAT_DEFAULT gst_gio_debug
 
@@ -91,11 +93,49 @@
   return ret;
 }
 
+static gpointer
+_internal_get_supported_protocols (gpointer data)
+{
+  const gchar *const *schemes;
+  gchar **our_schemes;
+  guint num;
+  gint i, j;
+
+  schemes = g_vfs_get_supported_uri_schemes (g_vfs_get_default ());
+  num = g_strv_length ((gchar **) schemes);
+
+  if (num == 0) {
+    GST_WARNING ("No GIO supported URI schemes found");
+    return NULL;
+  }
+
+  our_schemes = g_new0 (gchar *, num + 1);
+
+  /* - Filter http/https as we can't support the icy stuff with GIO.
+   *   Use souphttpsrc if you need that.
+   * - Filter cdda as it doesn't support musicbrainz stuff and everything
+   *   else one expects from a cdda source. Use cdparanoiasrc or cdiosrc
+   *   for cdda.
+   */
+  for (i = 0, j = 0; i < num; i++) {
+    if (strcmp (schemes[i], "http") == 0 || strcmp (schemes[i], "https") == 0
+        || strcmp (schemes[i], "cdda") == 0)
+      continue;
+
+    our_schemes[j] = g_strdup (schemes[i]);
+    j++;
+  }
+
+  return our_schemes;
+}
+
 static gchar **
 gst_gio_get_supported_protocols (void)
 {
-  return g_strdupv ((gchar **)
-      g_vfs_get_supported_uri_schemes (g_vfs_get_default ()));
+  static GOnce once = G_ONCE_INIT;
+
+  g_once (&once, _internal_get_supported_protocols, NULL);
+  return (gchar **) once.retval;
 }
 
 static GstURIType
diff -ur gst-plugins-base-0.10.19.orig/ext/gio/gstgiosink.c gst-plugins-base-0.10.19/ext/gio/gstgiosink.c
--- gst-plugins-base-0.10.19.orig/ext/gio/gstgiosink.c	2008-02-17 05:15:45.000000000 +0000
+++ gst-plugins-base-0.10.19/ext/gio/gstgiosink.c	2008-04-20 11:11:54.000000000 +0100
@@ -84,7 +84,8 @@
 enum
 {
   ARG_0,
-  ARG_LOCATION
+  ARG_LOCATION,
+  ARG_FILE
 };
 
 GST_BOILERPLATE_FULL (GstGioSink, gst_gio_sink, GstGioBaseSink,
@@ -100,18 +101,15 @@
 static void
 gst_gio_sink_base_init (gpointer gclass)
 {
-  static GstElementDetails element_details = {
-    "GIO sink",
-    "Sink/File",
-    "Write to any GIO-supported location",
-    "Ren\xc3\xa9 Stadler <mail@renestadler.de>, "
-        "Sebastian Dröge <slomo@circular-chaos.org>"
-  };
   GstElementClass *element_class = GST_ELEMENT_CLASS (gclass);
 
   GST_DEBUG_CATEGORY_INIT (gst_gio_sink_debug, "gio_sink", 0, "GIO sink");
 
-  gst_element_class_set_details (element_class, &element_details);
+  gst_element_class_set_details_simple (element_class, "GIO sink",
+      "Sink/File",
+      "Write to any GIO-supported location",
+      "Ren\xc3\xa9 Stadler <mail@renestadler.de>, "
+      "Sebastian Dröge <slomo@circular-chaos.org>");
 }
 
 static void
@@ -131,7 +129,18 @@
 
   g_object_class_install_property (gobject_class, ARG_LOCATION,
       g_param_spec_string ("location", "Location", "URI location to write to",
-          NULL, G_PARAM_READWRITE));
+          NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstGioSink:file
+   *
+   * %GFile to write to.
+   * 
+   * Since: 0.10.20
+   **/
+  g_object_class_install_property (gobject_class, ARG_FILE,
+      g_param_spec_object ("file", "File", "GFile to write to",
+          G_TYPE_FILE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
   gstbasesink_class->start = GST_DEBUG_FUNCPTR (gst_gio_sink_start);
 }
@@ -146,9 +155,9 @@
 {
   GstGioSink *sink = GST_GIO_SINK (object);
 
-  if (sink->location) {
-    g_free (sink->location);
-    sink->location = NULL;
+  if (sink->file) {
+    g_object_unref (sink->file);
+    sink->file = NULL;
   }
 
   GST_CALL_PARENT (G_OBJECT_CLASS, finalize, (object));
@@ -161,13 +170,49 @@
   GstGioSink *sink = GST_GIO_SINK (object);
 
   switch (prop_id) {
-    case ARG_LOCATION:
+    case ARG_LOCATION:{
+      const gchar *uri = NULL;
+
+      if (GST_STATE (sink) == GST_STATE_PLAYING ||
+          GST_STATE (sink) == GST_STATE_PAUSED) {
+        GST_WARNING
+            ("Setting a new location or GFile not supported in PLAYING or PAUSED state");
+        break;
+      }
+
+      GST_OBJECT_LOCK (GST_OBJECT (sink));
+      if (sink->file)
+        g_object_unref (sink->file);
+
+      uri = g_value_get_string (value);
+
+      if (uri) {
+        sink->file = g_file_new_for_uri (uri);
+
+        if (!sink->file) {
+          GST_ERROR ("Could not create GFile for URI '%s'", uri);
+        }
+      } else {
+        sink->file = NULL;
+      }
+      GST_OBJECT_UNLOCK (GST_OBJECT (sink));
+      break;
+    }
+    case ARG_FILE:
       if (GST_STATE (sink) == GST_STATE_PLAYING ||
-          GST_STATE (sink) == GST_STATE_PAUSED)
+          GST_STATE (sink) == GST_STATE_PAUSED) {
+        GST_WARNING
+            ("Setting a new location or GFile not supported in PLAYING or PAUSED state");
         break;
+      }
+
+      GST_OBJECT_LOCK (GST_OBJECT (sink));
+      if (sink->file)
+        g_object_unref (sink->file);
+
+      sink->file = g_value_dup_object (value);
 
-      g_free (sink->location);
-      sink->location = g_strdup (g_value_get_string (value));
+      GST_OBJECT_UNLOCK (GST_OBJECT (sink));
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -182,8 +227,24 @@
   GstGioSink *sink = GST_GIO_SINK (object);
 
   switch (prop_id) {
-    case ARG_LOCATION:
-      g_value_set_string (value, sink->location);
+    case ARG_LOCATION:{
+      gchar *uri;
+
+      GST_OBJECT_LOCK (GST_OBJECT (sink));
+      if (sink->file) {
+        uri = g_file_get_uri (sink->file);
+        g_value_set_string (value, uri);
+        g_free (uri);
+      } else {
+        g_value_set_string (value, NULL);
+      }
+      GST_OBJECT_UNLOCK (GST_OBJECT (sink));
+      break;
+    }
+    case ARG_FILE:
+      GST_OBJECT_LOCK (GST_OBJECT (sink));
+      g_value_set_object (value, sink->file);
+      GST_OBJECT_UNLOCK (GST_OBJECT (sink));
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -195,33 +256,28 @@
 gst_gio_sink_start (GstBaseSink * base_sink)
 {
   GstGioSink *sink = GST_GIO_SINK (base_sink);
-  GFile *file;
   GOutputStream *stream;
   GCancellable *cancel = GST_GIO_BASE_SINK (sink)->cancel;
   gboolean success;
   GError *err = NULL;
+  gchar *uri;
 
-  if (sink->location == NULL) {
+  if (sink->file == NULL) {
     GST_ELEMENT_ERROR (sink, RESOURCE, OPEN_WRITE, (NULL),
-        ("No location given"));
+        ("No location or GFile given"));
     return FALSE;
   }
 
-  file = g_file_new_for_uri (sink->location);
-
-  if (file == NULL) {
-    GST_ELEMENT_ERROR (sink, RESOURCE, OPEN_WRITE, (NULL),
-        ("Malformed URI or protocol not supported (%s)", sink->location));
-    return FALSE;
-  }
+  uri = g_file_get_uri (sink->file);
+  if (!uri)
+    uri = g_strdup ("(null)");
 
   stream =
-      G_OUTPUT_STREAM (g_file_create (file, G_FILE_CREATE_NONE, cancel, &err));
+      G_OUTPUT_STREAM (g_file_create (sink->file, G_FILE_CREATE_NONE, cancel,
+          &err));
 
   success = (stream != NULL);
 
-  g_object_unref (file);
-
   if (!success && !gst_gio_error (sink, "g_file_create", &err, NULL)) {
 
     /*if (GST_GIO_ERROR_MATCHES (err, EXISTS)) */
@@ -229,20 +285,21 @@
 
     if (GST_GIO_ERROR_MATCHES (err, NOT_FOUND))
       GST_ELEMENT_ERROR (sink, RESOURCE, NOT_FOUND, (NULL),
-          ("Could not open location %s for writing: %s",
-              sink->location, err->message));
+          ("Could not open location %s for writing: %s", uri, err->message));
     else
       GST_ELEMENT_ERROR (sink, RESOURCE, OPEN_READ, (NULL),
-          ("Could not open location %s for writing: %s",
-              sink->location, err->message));
+          ("Could not open location %s for writing: %s", uri, err->message));
 
+    g_free (uri);
     g_clear_error (&err);
   }
 
   if (!success)
     return FALSE;
 
-  GST_DEBUG_OBJECT (sink, "opened location %s", sink->location);
+  GST_DEBUG_OBJECT (sink, "opened location %s", uri);
+
+  g_free (uri);
 
   gst_gio_base_sink_set_stream (GST_GIO_BASE_SINK (sink), stream);
 
diff -ur gst-plugins-base-0.10.19.orig/ext/gio/gstgiosink.h gst-plugins-base-0.10.19/ext/gio/gstgiosink.h
--- gst-plugins-base-0.10.19.orig/ext/gio/gstgiosink.h	2008-02-15 11:58:06.000000000 +0000
+++ gst-plugins-base-0.10.19/ext/gio/gstgiosink.h	2008-04-20 11:11:54.000000000 +0100
@@ -53,10 +53,7 @@
   GstGioBaseSink sink;
 
   /*< private >*/
-  gchar *location;
-
-  GMainLoop *loop;
-  gboolean mount_successful;
+  GFile *file;
 };
 
 struct _GstGioSinkClass 
diff -ur gst-plugins-base-0.10.19.orig/ext/gio/gstgiosrc.c gst-plugins-base-0.10.19/ext/gio/gstgiosrc.c
--- gst-plugins-base-0.10.19.orig/ext/gio/gstgiosrc.c	2008-02-17 05:15:45.000000000 +0000
+++ gst-plugins-base-0.10.19/ext/gio/gstgiosrc.c	2008-06-12 15:19:17.000000000 +0100
@@ -72,6 +72,7 @@
 #endif
 
 #include "gstgiosrc.h"
+#include <string.h>
 
 GST_DEBUG_CATEGORY_STATIC (gst_gio_src_debug);
 #define GST_CAT_DEFAULT gst_gio_src_debug
@@ -79,41 +80,45 @@
 enum
 {
   ARG_0,
-  ARG_LOCATION
+  ARG_LOCATION,
+  ARG_FILE
 };
 
 GST_BOILERPLATE_FULL (GstGioSrc, gst_gio_src, GstGioBaseSrc,
     GST_TYPE_GIO_BASE_SRC, gst_gio_uri_handler_do_init);
 
 static void gst_gio_src_finalize (GObject * object);
+
 static void gst_gio_src_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec);
 static void gst_gio_src_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * pspec);
+
 static gboolean gst_gio_src_start (GstBaseSrc * base_src);
 
+static gboolean gst_gio_src_check_get_range (GstBaseSrc * base_src);
+
 static void
 gst_gio_src_base_init (gpointer gclass)
 {
-  static GstElementDetails element_details = {
-    "GIO source",
-    "Source/File",
-    "Read from any GIO-supported location",
-    "Ren\xc3\xa9 Stadler <mail@renestadler.de>, "
-        "Sebastian Dröge <slomo@circular-chaos.org>"
-  };
   GstElementClass *element_class = GST_ELEMENT_CLASS (gclass);
 
   GST_DEBUG_CATEGORY_INIT (gst_gio_src_debug, "gio_src", 0, "GIO source");
 
-  gst_element_class_set_details (element_class, &element_details);
+  gst_element_class_set_details_simple (element_class, "GIO source",
+      "Source/File",
+      "Read from any GIO-supported location",
+      "Ren\xc3\xa9 Stadler <mail@renestadler.de>, "
+      "Sebastian Dröge <slomo@circular-chaos.org>");
 }
 
 static void
 gst_gio_src_class_init (GstGioSrcClass * klass)
 {
   GObjectClass *gobject_class;
+
   GstElementClass *gstelement_class;
+
   GstBaseSrcClass *gstbasesrc_class;
 
   gobject_class = (GObjectClass *) klass;
@@ -126,9 +131,22 @@
 
   g_object_class_install_property (gobject_class, ARG_LOCATION,
       g_param_spec_string ("location", "Location", "URI location to read from",
-          NULL, G_PARAM_READWRITE));
+          NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstGioSrc:file
+   * 
+   * %GFile to read from.
+   * 
+   * Since: 0.10.20
+   **/
+  g_object_class_install_property (gobject_class, ARG_FILE,
+      g_param_spec_object ("file", "File", "GFile to read from",
+          G_TYPE_FILE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
   gstbasesrc_class->start = GST_DEBUG_FUNCPTR (gst_gio_src_start);
+  gstbasesrc_class->check_get_range =
+      GST_DEBUG_FUNCPTR (gst_gio_src_check_get_range);
 }
 
 static void
@@ -141,9 +159,9 @@
 {
   GstGioSrc *src = GST_GIO_SRC (object);
 
-  if (src->location) {
-    g_free (src->location);
-    src->location = NULL;
+  if (src->file) {
+    g_object_unref (src->file);
+    src->file = NULL;
   }
 
   GST_CALL_PARENT (G_OBJECT_CLASS, finalize, (object));
@@ -156,13 +174,49 @@
   GstGioSrc *src = GST_GIO_SRC (object);
 
   switch (prop_id) {
-    case ARG_LOCATION:
+    case ARG_LOCATION:{
+      const gchar *uri = NULL;
+
+      if (GST_STATE (src) == GST_STATE_PLAYING ||
+          GST_STATE (src) == GST_STATE_PAUSED) {
+        GST_WARNING
+            ("Setting a new location or GFile not supported in PLAYING or PAUSED state");
+        break;
+      }
+
+      GST_OBJECT_LOCK (GST_OBJECT (src));
+      if (src->file)
+        g_object_unref (src->file);
+
+      uri = g_value_get_string (value);
+
+      if (uri) {
+        src->file = g_file_new_for_uri (uri);
+
+        if (!src->file) {
+          GST_ERROR ("Could not create GFile for URI '%s'", uri);
+        }
+      } else {
+        src->file = NULL;
+      }
+      GST_OBJECT_UNLOCK (GST_OBJECT (src));
+      break;
+    }
+    case ARG_FILE:
       if (GST_STATE (src) == GST_STATE_PLAYING ||
-          GST_STATE (src) == GST_STATE_PAUSED)
+          GST_STATE (src) == GST_STATE_PAUSED) {
+        GST_WARNING
+            ("Setting a new location or GFile not supported in PLAYING or PAUSED state");
         break;
+      }
+
+      GST_OBJECT_LOCK (GST_OBJECT (src));
+      if (src->file)
+        g_object_unref (src->file);
 
-      g_free (src->location);
-      src->location = g_strdup (g_value_get_string (value));
+      src->file = g_value_dup_object (value);
+
+      GST_OBJECT_UNLOCK (GST_OBJECT (src));
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -177,8 +231,24 @@
   GstGioSrc *src = GST_GIO_SRC (object);
 
   switch (prop_id) {
-    case ARG_LOCATION:
-      g_value_set_string (value, src->location);
+    case ARG_LOCATION:{
+      gchar *uri;
+
+      GST_OBJECT_LOCK (GST_OBJECT (src));
+      if (src->file) {
+        uri = g_file_get_uri (src->file);
+        g_value_set_string (value, uri);
+        g_free (uri);
+      } else {
+        g_value_set_string (value, NULL);
+      }
+      GST_OBJECT_UNLOCK (GST_OBJECT (src));
+      break;
+    }
+    case ARG_FILE:
+      GST_OBJECT_LOCK (GST_OBJECT (src));
+      g_value_set_object (value, src->file);
+      GST_OBJECT_UNLOCK (GST_OBJECT (src));
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -187,52 +257,87 @@
 }
 
 static gboolean
+gst_gio_src_check_get_range (GstBaseSrc * base_src)
+{
+  GstGioSrc *src = GST_GIO_SRC (base_src);
+
+  gchar *scheme;
+
+  if (src->file == NULL)
+    goto done;
+
+  scheme = g_file_get_uri_scheme (src->file);
+  if (scheme == NULL)
+    goto done;
+
+  if (strcmp (scheme, "file") == 0) {
+    GST_LOG_OBJECT (src, "local URI, assuming random access is possible");
+    g_free (scheme);
+    return TRUE;
+  } else if (strcmp (scheme, "http") == 0 || strcmp (scheme, "https") == 0) {
+    GST_LOG_OBJECT (src, "blacklisted protocol '%s', "
+        "no random access possible", scheme);
+    g_free (scheme);
+    return FALSE;
+  }
+
+  g_free (scheme);
+
+done:
+
+  GST_DEBUG_OBJECT (src, "undecided about random access, asking base class");
+
+  return GST_CALL_PARENT_WITH_DEFAULT (GST_BASE_SRC_CLASS,
+      check_get_range, (base_src), FALSE);
+}
+
+
+static gboolean
 gst_gio_src_start (GstBaseSrc * base_src)
 {
   GstGioSrc *src = GST_GIO_SRC (base_src);
-  GFile *file;
+
   GError *err = NULL;
+
   GInputStream *stream;
-  GCancellable *cancel = GST_GIO_BASE_SRC (src)->cancel;
 
-  if (src->location == NULL) {
-    GST_ELEMENT_ERROR (src, RESOURCE, OPEN_READ, (NULL), ("No location given"));
-    return FALSE;
-  }
+  GCancellable *cancel = GST_GIO_BASE_SRC (src)->cancel;
 
-  file = g_file_new_for_uri (src->location);
+  gchar *uri = NULL;
 
-  if (file == NULL) {
+  if (src->file == NULL) {
     GST_ELEMENT_ERROR (src, RESOURCE, OPEN_READ, (NULL),
-        ("Malformed URI or protocol not supported (%s)", src->location));
+        ("No location or GFile given"));
     return FALSE;
   }
 
-  stream = G_INPUT_STREAM (g_file_read (file, cancel, &err));
+  uri = g_file_get_uri (src->file);
+  if (!uri)
+    uri = g_strdup ("(null)");
 
-  g_object_unref (file);
+  stream = G_INPUT_STREAM (g_file_read (src->file, cancel, &err));
 
   if (stream == NULL && !gst_gio_error (src, "g_file_read", &err, NULL)) {
-
     if (GST_GIO_ERROR_MATCHES (err, NOT_FOUND)) {
       GST_ELEMENT_ERROR (src, RESOURCE, NOT_FOUND, (NULL),
-          ("Could not open location %s for reading: %s",
-              src->location, err->message));
+          ("Could not open location %s for reading: %s", uri, err->message));
     } else {
       GST_ELEMENT_ERROR (src, RESOURCE, OPEN_READ, (NULL),
-          ("Could not open location %s for reading: %s",
-              src->location, err->message));
+          ("Could not open location %s for reading: %s", uri, err->message));
     }
 
+    g_free (uri);
     g_clear_error (&err);
     return FALSE;
   } else if (stream == NULL) {
+    g_free (uri);
     return FALSE;
   }
 
   gst_gio_base_src_set_stream (GST_GIO_BASE_SRC (src), stream);
 
-  GST_DEBUG_OBJECT (src, "opened location %s", src->location);
+  GST_DEBUG_OBJECT (src, "opened location %s", uri);
+  g_free (uri);
 
   return GST_BASE_SRC_CLASS (parent_class)->start (base_src);
 }
diff -ur gst-plugins-base-0.10.19.orig/ext/gio/gstgiosrc.h gst-plugins-base-0.10.19/ext/gio/gstgiosrc.h
--- gst-plugins-base-0.10.19.orig/ext/gio/gstgiosrc.h	2008-02-15 11:58:06.000000000 +0000
+++ gst-plugins-base-0.10.19/ext/gio/gstgiosrc.h	2008-04-20 11:11:54.000000000 +0100
@@ -53,10 +53,7 @@
   GstGioBaseSrc src;
   
   /*< private >*/
-  gchar *location;
-
-  GMainLoop *loop;
-  gboolean mount_successful;
+  GFile *file;
 };
 
 struct _GstGioSrcClass 
diff -ur gst-plugins-base-0.10.19.orig/ext/gio/gstgiostreamsink.c gst-plugins-base-0.10.19/ext/gio/gstgiostreamsink.c
--- gst-plugins-base-0.10.19.orig/ext/gio/gstgiostreamsink.c	2008-02-12 09:24:10.000000000 +0000
+++ gst-plugins-base-0.10.19/ext/gio/gstgiostreamsink.c	2008-03-22 15:00:42.000000000 +0000
@@ -129,7 +129,7 @@
 
   g_object_class_install_property (gobject_class, ARG_STREAM,
       g_param_spec_object ("stream", "Stream", "Stream to write to",
-          G_TYPE_OUTPUT_STREAM, G_PARAM_READWRITE));
+          G_TYPE_OUTPUT_STREAM, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 }
 
 static void
diff -ur gst-plugins-base-0.10.19.orig/ext/gio/gstgiostreamsrc.c gst-plugins-base-0.10.19/ext/gio/gstgiostreamsrc.c
--- gst-plugins-base-0.10.19.orig/ext/gio/gstgiostreamsrc.c	2008-02-12 09:24:10.000000000 +0000
+++ gst-plugins-base-0.10.19/ext/gio/gstgiostreamsrc.c	2008-03-22 15:00:42.000000000 +0000
@@ -123,7 +123,7 @@
 
   g_object_class_install_property (gobject_class, ARG_STREAM,
       g_param_spec_object ("stream", "Stream", "Stream to read from",
-          G_TYPE_INPUT_STREAM, G_PARAM_READWRITE));
+          G_TYPE_INPUT_STREAM, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 }
 
 static void
