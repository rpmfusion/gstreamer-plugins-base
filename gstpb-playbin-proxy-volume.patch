diff --git a/gst/playback/gstplaybin2.c b/gst/playback/gstplaybin2.c
index 1387a80..643c763 100644
--- a/gst/playback/gstplaybin2.c
+++ b/gst/playback/gstplaybin2.c
@@ -1091,6 +1091,18 @@ free_group (GstPlayBin * playbin, GstSourceGroup * group)
 }
 
 static void
+notify_volume_cb (GObject * selector, GParamSpec * pspec, GstPlayBin * playbin)
+{
+  g_object_notify (G_OBJECT (playbin), "volume");
+}
+
+static void
+notify_mute_cb (GObject * selector, GParamSpec * pspec, GstPlayBin * playbin)
+{
+  g_object_notify (G_OBJECT (playbin), "mute");
+}
+
+static void
 gst_play_bin_init (GstPlayBin * playbin)
 {
   GstFactoryListType type;
@@ -1116,6 +1128,11 @@ gst_play_bin_init (GstPlayBin * playbin)
   playbin->playsink = g_object_new (GST_TYPE_PLAY_SINK, NULL);
   gst_bin_add (GST_BIN_CAST (playbin), GST_ELEMENT_CAST (playbin->playsink));
   gst_play_sink_set_flags (playbin->playsink, DEFAULT_FLAGS);
+  /* Connect to notify::volume and notify::mute signals for proxying */
+  g_signal_connect (playbin->playsink, "notify::volume",
+      G_CALLBACK (notify_volume_cb), playbin);
+  g_signal_connect (playbin->playsink, "notify::mute",
+      G_CALLBACK (notify_mute_cb), playbin);
 
   playbin->encoding = g_strdup (DEFAULT_SUBTITLE_ENCODING);
 
diff --git a/gst/playback/gstplaysink.c b/gst/playback/gstplaysink.c
index 85f7abd..9809196 100644
--- a/gst/playback/gstplaysink.c
+++ b/gst/playback/gstplaysink.c
@@ -1421,6 +1421,19 @@ gen_subp_chain (GstPlaySink * playsink)
   return chain;
 }
 
+static void
+notify_volume_cb (GObject * selector, GParamSpec * pspec,
+    GstPlaySink * playsink)
+{
+  g_object_notify (G_OBJECT (playsink), "volume");
+}
+
+static void
+notify_mute_cb (GObject * selector, GParamSpec * pspec, GstPlaySink * playsink)
+{
+  g_object_notify (G_OBJECT (playsink), "mute");
+}
+
 /* make the chain that contains the elements needed to perform
  * audio playback.
  *
@@ -1497,6 +1510,9 @@ gen_audio_chain (GstPlaySink * playsink, gboolean raw, gboolean queue)
   if (elem) {
     chain->volume = elem;
 
+    g_signal_connect (chain->volume, "notify::volume",
+        G_CALLBACK (notify_volume_cb), playsink);
+
     GST_DEBUG_OBJECT (playsink, "the sink has a volume property");
     have_volume = TRUE;
     chain->sink_volume = TRUE;
@@ -1507,6 +1523,8 @@ gen_audio_chain (GstPlaySink * playsink, gboolean raw, gboolean queue)
         gst_play_sink_find_property_sinks (playsink, chain->sink, "mute");
     if (chain->mute) {
       GST_DEBUG_OBJECT (playsink, "the sink has a mute property");
+      g_signal_connect (chain->mute, "notify::mute",
+          G_CALLBACK (notify_mute_cb), playsink);
     }
     /* use the sink to control the volume and mute */
     if (playsink->volume_changed) {
@@ -1575,6 +1593,11 @@ gen_audio_chain (GstPlaySink * playsink, gboolean raw, gboolean queue)
       } else {
         have_volume = TRUE;
 
+        g_signal_connect (chain->volume, "notify::volume",
+            G_CALLBACK (notify_volume_cb), playsink);
+        g_signal_connect (chain->mute, "notify::mute",
+            G_CALLBACK (notify_mute_cb), playsink);
+
         /* volume also has the mute property */
         chain->mute = chain->volume;
 
@@ -1687,6 +1710,9 @@ setup_audio_chain (GstPlaySink * playsink, gboolean raw, gboolean queue)
       /* use the sink to control the volume */
       g_object_set (G_OBJECT (chain->volume), "volume", playsink->volume, NULL);
     }
+
+    g_signal_connect (chain->volume, "notify::volume",
+        G_CALLBACK (notify_volume_cb), playsink);
     /* if the sink also has a mute property we can use this as well. We'll only
      * use the mute property if there is a volume property. We can simulate the
      * mute with the volume otherwise. */
@@ -1694,12 +1720,22 @@ setup_audio_chain (GstPlaySink * playsink, gboolean raw, gboolean queue)
         gst_play_sink_find_property_sinks (playsink, chain->sink, "mute");
     if (chain->mute) {
       GST_DEBUG_OBJECT (playsink, "the sink has a mute property");
+      g_signal_connect (chain->mute, "notify::mute",
+          G_CALLBACK (notify_mute_cb), playsink);
     }
   } else {
     /* no volume, we need to add a volume element when we can */
     GST_DEBUG_OBJECT (playsink, "the sink has no volume property");
     if (!raw) {
       GST_LOG_OBJECT (playsink, "non-raw format, can't do soft volume control");
+
+      if (chain->volume)
+        g_signal_handlers_disconnect_by_func (chain->volume, notify_volume_cb,
+            playsink);
+      if (chain->mute)
+        g_signal_handlers_disconnect_by_func (chain->mute, notify_mute_cb,
+            playsink);
+
       chain->volume = NULL;
       chain->mute = NULL;
     } else {
diff --git a/gst/playback/gstplaysink.c b/gst/playback/gstplaysink.c
index 9809196..a481203 100644
--- a/gst/playback/gstplaysink.c
+++ b/gst/playback/gstplaysink.c
@@ -1422,15 +1422,24 @@ gen_subp_chain (GstPlaySink * playsink)
 }
 
 static void
-notify_volume_cb (GObject * selector, GParamSpec * pspec,
-    GstPlaySink * playsink)
+notify_volume_cb (GObject * object, GParamSpec * pspec, GstPlaySink * playsink)
 {
+  gdouble vol;
+
+  g_object_get (object, "volume", &vol, NULL);
+  playsink->volume = vol;
+
   g_object_notify (G_OBJECT (playsink), "volume");
 }
 
 static void
-notify_mute_cb (GObject * selector, GParamSpec * pspec, GstPlaySink * playsink)
+notify_mute_cb (GObject * object, GParamSpec * pspec, GstPlaySink * playsink)
 {
+  gboolean mute;
+
+  g_object_get (object, "mute", &mute, NULL);
+  playsink->mute = mute;
+
   g_object_notify (G_OBJECT (playsink), "mute");
 }
 
diff --git a/gst/playback/gstplaysink.c b/gst/playback/gstplaysink.c
index a481203..8c89203 100644
--- a/gst/playback/gstplaysink.c
+++ b/gst/playback/gstplaysink.c
@@ -1538,6 +1538,7 @@ gen_audio_chain (GstPlaySink * playsink, gboolean raw, gboolean queue)
     /* use the sink to control the volume and mute */
     if (playsink->volume_changed) {
       g_object_set (G_OBJECT (chain->volume), "volume", playsink->volume, NULL);
+      playsink->volume_changed = FALSE;
     }
     if (playsink->mute_changed) {
       if (chain->mute) {
@@ -1546,6 +1547,7 @@ gen_audio_chain (GstPlaySink * playsink, gboolean raw, gboolean queue)
         if (playsink->mute)
           g_object_set (chain->volume, "volume", (gdouble) 0.0, NULL);
       }
+      playsink->mute_changed = FALSE;
     }
   } else {
     /* no volume, we need to add a volume element when we can */
@@ -1718,6 +1720,7 @@ setup_audio_chain (GstPlaySink * playsink, gboolean raw, gboolean queue)
           playsink->volume);
       /* use the sink to control the volume */
       g_object_set (G_OBJECT (chain->volume), "volume", playsink->volume, NULL);
+      playsink->volume_changed = FALSE;
     }
 
     g_signal_connect (chain->volume, "notify::volume",

